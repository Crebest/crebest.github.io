# 每周一道算法题：
189.轮转数组：
```java
class Solution {
    public void rotate(int[] nums, int k) {

        k = k % nums.length;

        int[] res = new int[nums.length];

        for(int i = 0;i < k;i++) {
           res[i] = nums[nums.length - k + i];
        }

        for(int i = k;i < nums.length;i++) {
            res[i] = nums[i - k];
        }

        for(int i = 0;i < nums.length;i++) {
            nums[i] = res[i];
        }
    }
}
```
# 每周一篇文章点评：
文章链接： </br>
点评：

# 每周一个小技巧：
推荐一个适合开发用的翻译工具：
https://www.deepl.com/zh/translator
# 每周一篇学习分享：
接口切换，如何保持数据一致性？</br>

比如，这个场景：A服务要调用B服务的C1接口，但因为种种原因，B服务组装了新的C2接口。A是调用方，B是提供方。</br>

针对这种情况，我们可以有两种方式来处理：</br>

方式1：</br>
涉及到技术改造的时候，如果B服务不想麻烦别人，可以继续用C1接口作为门面，然后通过门面来灰度到C2接口。这样的话，表面走的是C1接口，实际走的C2接口的逻辑。<br>

方式2：</br>
如果B服务作为提供方，不想用门面，或者实际情况没法用门面模式解决时，比如新的团队接手B服务，不好改B服务里的代码；或者因为各种各样的权限问题；再或者不想让别人改你代码。新团队就要搞一个B2服务。</br>

这时的方案：A调用方 --->  B2服务方 </br>

旧的调用链路是：</br>
a服务 ---> b服务(c1接口)  </br>

新的的调用链路是：</br>
a服务 ---> b2服务(c2接口)  </br>

小结： </br>
1.方式1是服务方自己做好兼容方式，对调用方是友好，无感知；</br>
2.方式2是需要各个调用方配合改造，切换接口才行，因此人力成本是增多了的。</br>

那么数据一致性怎么保证？ </br>

首先，明确这里的一致是指：入参一致，新老接口的出参也要一致。  </br>

有两种方法：</br>

方法1：服务方校验数据的一致性，调用方只管调用。</br>

如果是方法1，服务方在设计接口的时候，在新入参的基础上，额外增加一个字段，即老接口的入参。 </br>

服务方在获取调用方传过来的新入参和老接口的原有入参，做以下3步：</br>

第一步：通过新的入参，执行程序，获取到新的出参1；</br>

第二步：通过老接口的原有入参，执行老程序，得到出参2；</br>

第三步：通过对比出参1和出参2，如果有不一致的情况，进行监控和报警，且返回出参2；如果一致，返回出参1。</br>

方法2：服务方不校验数据的一致性，调用方进行校验。</br>

如果是方法2（双链路对比），需要调用方来校验一致性，应该如何检验。</br>

第一步：调用新接口，获取到新的出参1；</br>

第二步：调用老接口，但增加接口的调用，是会增加总体耗时的，所以这里需要非阻塞调用，获取出参2；</br>

第三步：开一个线程，异步对比出参1和出参2，如果有不一致的情况，进行监控和报警，但这里只能返回出参1。因为这里是异步的对比，如果硬要返回出参2，则需进行同步对比。</br>

