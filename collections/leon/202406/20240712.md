# 每周一道算法题：

[22.括号生成](https://leetcode.cn/problems/generate-parentheses/description/)

```Java
class Solution {
  public List<String> generateParenthesis(int n) {
    List<String> res = new ArrayList<>();
    dfs(res, new StringBuilder(), 0, 0, n);
    return res;
  }

  private void dfs(List<String> res, StringBuilder str, int left, int right, int n) {
    if (str.length() == 2 * n) {
      res.add(str.toString());
      return;
    }
    if (left < n) {
      dfs(res, str.append('('), left+1, right, n);
      str.deleteCharAt(str.length() - 1);
    }
    if (left > right) {
      dfs(res, str.append(')'), left, right+1, n);
      str.deleteCharAt(str.length() - 1);
    }
  }
}
```

# 每周一篇文章点评：

为什么有些时候虚拟线程比平台线程慢

[Why are my Java virtual threads slower than the platform threads?](https://medium.com/ascend-developers/why-are-my-java-virtual-threads-slower-than-the-platform-threads-74612a1587f3)

- synchronize锁导致平台线程不能释放
- 本地方法和脚本不支持虚拟线程
- JDBC等不支持的库

# 每周一个小技巧：

通过修改 hosts 文件访问 GitHub 解决 DNS 污染问题，GitHub 的 IP 经常变化，[GitHub-IP-hosts](https://github.com/ittuann/GitHub-IP-hosts) 项目提供 GitHub IP 的 hosts 文件，添加到本机 hosts 文件，项目每天更新。

# 每周一篇学习分享：

使用 `hibernate validation` 优雅实现参数校验

1. 添加依赖，spring-boot版本大于2.3.x的情况需要手动引入

   ```xml
   <dependency>
       <groupId>org.hibernate</groupId>
       <artifactId>hibernate-validator</artifactId>
       <version>6.0.1.Final</version>
   </dependency>
   
2. 对`RequestBody`进行校验，指定message参数作为报错信息，

  ```java
  @Data
  @Accessors(chain = true)
  public class User {
    @NotNull
    Long id;
    
    @NotEmpty(message = "请输入姓名")
    String name;
    
    @NotNull
    Date birthday;
  }
  ```

3. 使用`@Retryable`开启异步重试

  ```java
    @Async
    @Retryable(retryFor = RuntimeException.class, maxAttempts = 4, backoff = @Backoff(delay = 100))
    public void sendNotification() {
      log.info("开始发送消息");
      //模拟随机网络异常
      if (Math.random() > 0.5) {
        log.error("发送消息失败");
        throw new RuntimeException("Network error");
      }
      log.info("发送消息成功!");
    }
  ```

  `@Retryable`注解参数:
  - `retryFor`：指定重试的异常类型，默认为空，表示重试所有异常
  - `maxAttempts`：指定最大重试次数
  - `backoff`：指定多少毫秒后重试
4. `@Recover`注解用于处理重试失败的情况
   
   ```java
     @Recover
    public void recover(RuntimeException e) {
    log.error("消息发送失败，重试失败，异常信息：{}", e.getMessage());
    }
   ```

要实现一个线程安全的map，首先可以想到的是在普通HashMap的基础上，put和get操作时，锁住整个map，为了提高性能，只对put操作加锁，进一步优化发现，锁住整个map对性能影响大，jdk的做法是把key按照hash值分成多个segment，put操作时，通过hash值找到对应的segment，只锁住对应的segment，其他setment的操作不受影响