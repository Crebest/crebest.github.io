---
title: pitayafruit的ARTS打卡记录 2024-08-02=9
---

# 每周一道算法题：
238.除自身以外的乘法 
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        if (len == 0) return new int[0];
        int[] ans = new int[len];
        ans[0] = 1;
        int tmp = 1;
        for (int i = 1; i < len; i++) {
            ans[i] = ans[i - 1] * nums[i - 1];
        }
        for (int i = len - 2; i >= 0; i--) {
            tmp *= nums[i + 1];
            ans[i] *= tmp;
        }
        return ans;
    }
}
```
# 每周一篇文章点评：
文章链接： https://time.geekbang.org/column/intro/100020801</br>
极客时间MySQL实战45讲：08 | 事务到底是隔离的还是不隔离的？</br>
点评：</br>
知识点总结：</br>
- 事务隔离级别：</br>
  可重复读和读已提交隔离级别是通过一致性的读视图（Consistent Read View）来实现的。在RR隔离级别下，事务启动时创建视图，之后事务中的所有查询都将使用这个视图，即使有其他事务修改了数据，当前事务看到的仍是启动时的数据状态。</br>
- 快照读与当前读：</br>
  一致性读（快照读）用于SELECT语句，在事务启动时或在特定隔离级别下（如RC）每次执行查询时创建，它基于事务启动时的快照读取数据，不考虑其他事务的更改。</br>
  当前读用于UPDATE和加锁的SELECT语句，它总是读取已经提交的最新版本的数据，如果数据被其他事务锁定，则当前读将等待锁释放。</br>
- 事务版本号与数据版本：</br>
  每个事务都有一个唯一的事务ID（transaction id），按申请顺序递增。</br>
  数据有多版本，每次事务更新数据时，生成一个新的数据版本，包含事务ID（row trx_id），旧版本保留。</br>
- 读视图与事务ID：</br>
  在RR隔离级别下，事务启动时创建一致性读视图，包含一个事务ID数组，记录当前活跃的所有事务ID。</br>
  视图数组中的最小事务ID被称为低水位，用于确定数据的可见性。</br>
- 数据版本的可见性规则：</br>
  数据版本的可见性取决于其row trx_id与当前事务视图的关系。</br>
  事务在执行更新时，会基于当前最新版本的数据进行，即使该版本来自其他事务且尚未提交，这也称为“当前读”。</br>
- 锁与等待：</br>
  如果事务尝试更新的行被其他事务锁定，它将进入等待状态直到锁被释放。</br>
  两阶段锁协议确保事务在更新数据时不丢失其他事务的修改。</br>
- 隔离级别差异：</br>
   RR和RC的主要区别在于视图的创建时机：RR在事务开始时创建，之后所有查询共享此视图；RC在每个当前读前重新计算视图。</br>
# 每周一个小技巧：



# 每周一篇学习分享：
https://juejin.cn/post/7395866537495330879
