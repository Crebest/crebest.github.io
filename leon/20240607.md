# 每周一道算法题：
## [leetcode 24 两两交换链表节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
```Java
class Solution {
  public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    ListNode res = head;
    int temp;
    while (head.next != null) {
      temp = head.val;
      head.val = head.next.val;
      head.next.val = temp;
      if (head.next.next != null) {
        head = head.next.next;
      } else {
        break;
      }
    }
    return res;
  }
}
```

# 每周一篇文章点评：
[6 Tips for Resolving Common Java Performance Problems（Java 性能问题优化）](https://medium.com/javarevisited/6-tips-for-resolving-common-java-performance-problems-b88f42dc6118)

优化 Java 性能问题的措施：  
- 防止内存泄漏，确保不再使用的对象被回收
- 优化 JVM 垃圾回收，根据需求配置 JVM 参数，选择合适的垃圾回收算法
- 避免线程死锁，确保一致的锁获取顺序，使用超时机制避免无限等待
- 减少臃肿的库和依赖，清理不必要的依赖
- 优化SQL查询和数据库访问，大量数据批量处理，使用连接池复用数据库连接
- 根据需求选择合适的数据结构


# 每周一个小技巧：
使用sdkman安装管理多个Java版本：  
[sdkman](https://sdkman.io/usage)



# 每周一篇学习分享：

### fastjson Date 序列化问题

使用`@JSONField(format = "yyyy-MM-dd")`注解不生效

```Java
@Data
@Accessors(chain = true)
public class User {
  private Long id;
  private String name;
  @JSONField(format = "yyyy-MM-dd")
  private Date birthday;
}
```
得到的结果：
```json
{
  "birthday": "2024-05-31 12:53:25",
  "id": 1,
  "name": "John"
}
```
#### 原因分析  
配置 fastjson 时指定了全局序列化方式
``` Java
  @Override
  public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
    //配置fastjson
    FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();
    List<MediaType> supportMediaTypeList = new ArrayList<>();
    supportMediaTypeList.add(MediaType.APPLICATION_JSON);
    FastJsonConfig config = new FastJsonConfig();
    //日期序列化
    config.setDateFormat("yyyy-MM-dd HH:mm:ss");
    config.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect, SerializerFeature.WriteMapNullValue);
    converter.setFastJsonConfig(config);
    converter.setSupportedMediaTypes(supportMediaTypeList);
    converter.setDefaultCharset(StandardCharsets.UTF_8);
    converters.add(0, converter);
  }
  ```
  在老版本的 fastjson 中，默认序列化方式的优先级最高，导致通过注解的方式配置的序列化方式被忽略：
  ```Java
  　　public final void writeWithFormat(Object object, String format) {
        if (object instanceof Date) {
            DateFormat dateFormat = this.getDateFormat();
            if (dateFormat == null) {
                //只有当默认的dateFormat为null时，才会使用其他方式的序列化方式
                dateFormat = new SimpleDateFormat(format, locale);
                dateFormat.setTimeZone(timeZone);
            }
            String text = dateFormat.format((Date) object);
            out.writeString(text);
            return;
        }
        //...
  }
  ```
  #### 解决方案：
   升级 fastjson 最新版本，新版本中默认序列化方式的优先级比注解方式高，所以注解方式生效。
